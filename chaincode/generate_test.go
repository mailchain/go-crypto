package chaincode

import (
	"testing"

	"github.com/mailchain/encoding/encodingtest"
	"github.com/stretchr/testify/assert"
)

func TestChainCodeFromDeriveIndexBytes(t *testing.T) {
	type args struct {
		input []byte
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{
			"0",
			args{
				encodingtest.MustDecodeHex("0000000000000000000000000000000000000000000000000000000000000000"),
			},
			[]byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
		},
		{
			"16-FF",
			args{
				encodingtest.MustDecodeHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
			},
			[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
		},
		{
			"32-FF",
			args{
				encodingtest.MustDecodeHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
			},
			[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
		},
		{
			"64-FF",
			args{
				encodingtest.MustDecodeHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"),
			},
			[]byte{0x41, 0xdb, 0x9, 0x6e, 0x15, 0xf0, 0x3b, 0x13, 0x5b, 0x4, 0xe9, 0x9e, 0x84, 0x8e, 0xf, 0x76, 0xcb, 0x37, 0x39, 0xc3, 0x5f, 0xfe, 0x7, 0xe3, 0x67, 0x9d, 0xf3, 0x78, 0x67, 0xbc, 0xb5, 0x73},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.want, ChainCodeFromDeriveIndexBytes(tt.args.input))
		})
	}
}

func TestChainCodeFromDeriveIndexUint64(t *testing.T) {
	type args struct {
		input uint64
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{
			"10",
			args{
				10,
			},
			[]byte{0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
		},
		{
			"1000",
			args{
				1000,
			},
			[]byte{0xe8, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.want, ChainCodeFromDeriveIndexUint64(tt.args.input))
		})
	}
}

func TestChainCodeFromDeriveIndexString(t *testing.T) {
	type args struct {
		input string
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{
			"short",
			args{
				"short",
			},
			encodingtest.MustDecodeHex("1473686f72740000000000000000000000000000000000000000000000000000"),
		},
		{
			"short-string",
			args{
				"short-string",
			},
			encodingtest.MustDecodeHex("3073686f72742d737472696e6700000000000000000000000000000000000000"),
		},
		{
			"long-string",
			args{
				"string longer than chain code length of 32 bytes",
			},
			encodingtest.MustDecodeHex("79a03475da2fcd8d43e22be1f0f15946f171571506008baa381fecc84373ddea"),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.want, ChainCodeFromDeriveIndexString(tt.args.input))
		})
	}
}
